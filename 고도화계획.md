# 🚀 Naver Stock Agent 고도화 계획

> **작성일**: 2026-01-04  
> **목적**: 시스템 안정성, 관찰성, 코드 품질 향상을 위한 단계별 개선 계획

---

## 📊 현재 시스템 분석

### 강점
- ✅ 멀티 에이전트 아키텍처 (LangGraph 기반)
- ✅ SQL + RAG 하이브리드 시스템
- ✅ LangSmith 통합 (추적 가능)
- ✅ Streamlit UI 제공

### 개선 필요 영역
- ⚠️ 에러 핸들링 부족 (무한 루프 위험)
- ⚠️ 로깅 시스템 미비 (디버깅 어려움)
- ⚠️ State 관리 불명확
- ⚠️ FastAPI와 Streamlit 코드 혼재

---

## 🎯 고도화 로드맵

| 단계 | 작업 | 우선순위 | 예상 시간 | 영향도 |
|-----|------|---------|----------|--------|
| 1단계 | 에러 핸들링 + 재시도 로직 | 🔴 최고 | 3-4시간 | 안정성 ↑↑↑ |
| 2단계 | 로깅 시스템 구축 | 🟠 높음 | 2-3시간 | 관찰성 ↑↑↑ |
| 3단계 | State 정의 추가 | 🟡 중간 | 2시간 | 유지보수성 ↑↑ |
| 4단계 | main.py 분리 + LangServe | 🟡 중간 | 1-2시간 | 개발 경험 ↑↑ |
| 5단계 | Structured Output 적용 | 🟢 낮음 | 2시간 | 코드 품질 ↑ |

---

## 1단계: 에러 핸들링 + 재시도 로직 강화 ⚠️

### 현재 문제점

**파일**: `Agent-yj/src/agent.py`

```python
# Line 92-104: 현재 코드
def handle_tool_error(state) -> dict:
    """에러 정보를 도구 메시지로 반환"""
    error = state.get('error')
    tool_calls = state['messages'][-1].tool_calls
    return {
        'messages': [
            ToolMessage(
                content=f'Here is error: {repr(error)}\n\nPlease fix your mistake',
                tool_call_id=tc['id'],
            )
            for tc in tool_calls
        ]
    }
```

**문제**:
- ❌ 재시도 횟수 제한 없음 → 무한 루프 가능
- ❌ 에러 타입별 처리 없음
- ❌ 비용 폭증 위험 (무제한 LLM 호출)
- ❌ 사용자에게 실패 이유 불명확

### 개선 방안

#### 1.1 에러 타입 정의

**새 파일 생성**: `Agent-yj/src/errors.py`

```python
"""
에이전트 에러 타입 정의
"""
from enum import Enum
from typing import Optional
from pydantic import BaseModel

class ErrorSeverity(str, Enum):
    """에러 심각도"""
    LOW = "low"           # 재시도 가능
    MEDIUM = "medium"     # 재시도 제한적
    HIGH = "high"         # 즉시 중단
    CRITICAL = "critical" # 시스템 에러

class ErrorType(str, Enum):
    """에러 유형"""
    SQL_SYNTAX_ERROR = "sql_syntax_error"
    SQL_EXECUTION_ERROR = "sql_execution_error"
    TOOL_CALL_ERROR = "tool_call_error"
    LLM_API_ERROR = "llm_api_error"
    RAG_RETRIEVAL_ERROR = "rag_retrieval_error"
    VALIDATION_ERROR = "validation_error"
    TIMEOUT_ERROR = "timeout_error"
    UNKNOWN_ERROR = "unknown_error"

class AgentError(BaseModel):
    """구조화된 에러 정보"""
    error_type: ErrorType
    severity: ErrorSeverity
    message: str
    agent_name: Optional[str] = None
    retry_count: int = 0
    original_error: Optional[str] = None
    timestamp: str

def classify_error(error: Exception, agent_name: str) -> AgentError:
    """에러를 분류하고 구조화"""
    import datetime
    
    error_str = str(error).lower()
    
    # SQL 에러
    if "syntax error" in error_str or "sql" in error_str:
        return AgentError(
            error_type=ErrorType.SQL_SYNTAX_ERROR,
            severity=ErrorSeverity.MEDIUM,
            message=f"SQL 쿼리 오류: {str(error)}",
            agent_name=agent_name,
            original_error=str(error),
            timestamp=datetime.datetime.now().isoformat()
        )
    
    # LLM API 에러
    elif "api" in error_str or "rate limit" in error_str:
        return AgentError(
            error_type=ErrorType.LLM_API_ERROR,
            severity=ErrorSeverity.HIGH,
            message=f"LLM API 오류: {str(error)}",
            agent_name=agent_name,
            original_error=str(error),
            timestamp=datetime.datetime.now().isoformat()
        )
    
    # 타임아웃
    elif "timeout" in error_str:
        return AgentError(
            error_type=ErrorType.TIMEOUT_ERROR,
            severity=ErrorSeverity.MEDIUM,
            message=f"실행 시간 초과: {str(error)}",
            agent_name=agent_name,
            original_error=str(error),
            timestamp=datetime.datetime.now().isoformat()
        )
    
    # 기타
    else:
        return AgentError(
            error_type=ErrorType.UNKNOWN_ERROR,
            severity=ErrorSeverity.MEDIUM,
            message=f"알 수 없는 오류: {str(error)}",
            agent_name=agent_name,
            original_error=str(error),
            timestamp=datetime.datetime.now().isoformat()
        )
```

#### 1.2 State에 재시도 정보 추가

**파일 수정**: `Agent-yj/src/agent.py`

```python
# Line 14-15 이후에 추가
from typing_extensions import TypedDict

class AgentState(TypedDict):
    """에이전트 상태 정의"""
    messages: Sequence[BaseMessage]
    
    # 재시도 관련
    retry_count: int
    max_retries: int
    
    # 에러 추적
    error_history: List[Dict[str, Any]]
    last_error: Optional[Dict[str, Any]]
    
    # 실행 메타데이터
    start_time: Optional[str]
    agent_trace: List[str]  # 실행된 에이전트 목록
    
    # SQL 관련
    sql_query: Optional[str]
    query_results: Optional[str]
```

#### 1.3 재시도 로직 구현

**파일 수정**: `Agent-yj/src/agent.py`

```python
# Line 92-104 대체
from .errors import classify_error, ErrorSeverity, AgentError

MAX_RETRIES = 3  # 전역 상수

def handle_tool_error(state: AgentState) -> dict:
    """
    개선된 에러 핸들러: 재시도 횟수 제한 + 에러 분류
    """
    error = state.get('error')
    retry_count = state.get('retry_count', 0)
    max_retries = state.get('max_retries', MAX_RETRIES)
    
    # 에러 분류
    agent_name = "unknown"
    if state['messages'] and hasattr(state['messages'][-1], 'name'):
        agent_name = state['messages'][-1].name
    
    classified_error = classify_error(error, agent_name)
    
    # 재시도 가능 여부 판단
    if retry_count >= max_retries:
        # 최대 재시도 초과
        return {
            'messages': [
                AIMessage(
                    content=f"죄송합니다. 여러 번 시도했지만 작업을 완료할 수 없습니다.\n\n"
                            f"오류 유형: {classified_error.error_type}\n"
                            f"오류 메시지: {classified_error.message}\n\n"
                            f"다른 방식으로 질문해 주시겠어요?"
                )
            ]
        }
    
    # 심각도에 따른 처리
    if classified_error.severity == ErrorSeverity.CRITICAL:
        # 즉시 중단
        return {
            'messages': [
                AIMessage(
                    content=f"시스템 오류가 발생했습니다: {classified_error.message}\n"
                            f"관리자에게 문의해주세요."
                )
            ]
        }
    
    # 재시도
    tool_calls = state['messages'][-1].tool_calls if hasattr(state['messages'][-1], 'tool_calls') else []
    
    return {
        'messages': [
            ToolMessage(
                content=f'오류가 발생했습니다 (재시도 {retry_count + 1}/{max_retries}):\n'
                        f'{classified_error.message}\n\n'
                        f'다른 방법으로 시도해주세요.',
                tool_call_id=tc['id'],
            )
            for tc in tool_calls
        ],
        'retry_count': retry_count + 1,
        'error_history': state.get('error_history', []) + [classified_error.dict()],
        'last_error': classified_error.dict()
    }
```

#### 1.4 타임아웃 설정

**파일 수정**: `Agent-yj/src/agent.py`

```python
# Line 51-58 수정 (모델 설정 부분)
if api_key_openai:
    default_model = ChatOpenAI(
        model='gpt-4o-mini', 
        api_key=api_key_openai, 
        temperature=0,
        timeout=30,  # 30초 타임아웃 추가
        max_retries=2  # LLM 자체 재시도
    )
    model_name = 'openai:gpt-4o-mini'
elif api_key_clova:
    default_model = ChatClovaX(
        model='HCX-005', 
        api_key=api_key_clova, 
        max_tokens=4096, 
        temperature=0, 
        top_k=3,
        timeout=30  # 30초 타임아웃 추가
    )
    model_name = 'HCX-005'
```

### 작업 체크리스트

- [ ] `src/errors.py` 파일 생성
- [ ] `AgentState` TypedDict 정의
- [ ] `handle_tool_error` 함수 개선
- [ ] LLM 모델에 타임아웃 설정
- [ ] StateGraph를 `MessagesState` → `AgentState`로 변경
- [ ] 모든 노드에서 retry_count 초기화
- [ ] 테스트: 의도적으로 잘못된 쿼리 실행해보기

---

## 2단계: 로깅 시스템 구축 📊

### 현재 문제점

```python
# Line 162: print만 사용
print("⚠️ RAG 모듈을 찾을 수 없습니다.")

# Line 616-636: print로 테스트 결과 출력
print("✅ 멀티 에이전트 시스템이 성공적으로 로드되었습니다.")
```

**문제**:
- 프로덕션 환경에서 로그 추적 불가
- 성능 병목 지점 파악 어려움
- 디버깅 시간 증가

### 개선 방안

#### 2.1 로깅 설정 파일

**새 파일 생성**: `Agent-yj/src/logger.py`

```python
"""
구조화된 로깅 시스템
"""
import logging
import sys
from pathlib import Path
from datetime import datetime
import json

# 로그 디렉토리 생성
LOG_DIR = Path(__file__).parent.parent / "logs"
LOG_DIR.mkdir(exist_ok=True)

# 로그 파일명 (날짜별)
LOG_FILE = LOG_DIR / f"agent_{datetime.now().strftime('%Y%m%d')}.log"

class StructuredFormatter(logging.Formatter):
    """JSON 형식 로깅"""
    
    def format(self, record):
        log_data = {
            "timestamp": datetime.now().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno,
        }
        
        # 추가 필드
        if hasattr(record, 'agent_name'):
            log_data['agent_name'] = record.agent_name
        if hasattr(record, 'duration_ms'):
            log_data['duration_ms'] = record.duration_ms
        if hasattr(record, 'tokens_used'):
            log_data['tokens_used'] = record.tokens_used
        if hasattr(record, 'error_type'):
            log_data['error_type'] = record.error_type
            
        return json.dumps(log_data, ensure_ascii=False)

def setup_logger(name: str = "stock_agent", level: int = logging.INFO):
    """로거 설정"""
    logger = logging.getLogger(name)
    logger.setLevel(level)
    
    # 기존 핸들러 제거
    logger.handlers.clear()
    
    # 파일 핸들러 (JSON)
    file_handler = logging.FileHandler(LOG_FILE, encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(StructuredFormatter())
    logger.addHandler(file_handler)
    
    # 콘솔 핸들러 (사람이 읽기 쉬운 형식)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    console_formatter = logging.Formatter(
        '%(asctime)s | %(levelname)-8s | %(name)s | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)
    
    return logger

# 전역 로거
logger = setup_logger()
```

#### 2.2 에이전트 실행 로깅

**파일 수정**: `Agent-yj/src/agent.py`

```python
# 파일 상단에 추가 (Line 12 이후)
from .logger import logger
import time

# 각 에이전트를 래핑하는 로깅 데코레이터
def log_agent_execution(agent_name: str):
    """에이전트 실행을 로깅하는 데코레이터"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            
            logger.info(
                f"Agent started: {agent_name}",
                extra={"agent_name": agent_name}
            )
            
            try:
                result = func(*args, **kwargs)
                duration_ms = int((time.time() - start_time) * 1000)
                
                logger.info(
                    f"Agent completed: {agent_name}",
                    extra={
                        "agent_name": agent_name,
                        "duration_ms": duration_ms,
                        "success": True
                    }
                )
                
                return result
                
            except Exception as e:
                duration_ms = int((time.time() - start_time) * 1000)
                
                logger.error(
                    f"Agent failed: {agent_name}",
                    extra={
                        "agent_name": agent_name,
                        "duration_ms": duration_ms,
                        "success": False,
                        "error_type": type(e).__name__,
                        "error_message": str(e)
                    },
                    exc_info=True
                )
                
                raise
        
        return wrapper
    return decorator
```

#### 2.3 주요 함수에 로깅 적용

**파일 수정**: `Agent-yj/src/agent.py`

```python
# Line 68-88: db_query_tool 수정
@tool
def db_query_tool(query: str) -> str:
    """
    Run SQL queries against a database and return results.
    """
    logger.info(f"Executing SQL query", extra={"query": query[:100]})
    
    start_time = time.time()
    result = db.run_no_throw(query)
    duration_ms = int((time.time() - start_time) * 1000)
    
    # 1) 쿼리 실패
    if isinstance(result, str) and result.startswith("Error:"):
        logger.error(
            "SQL query failed",
            extra={"query": query, "duration_ms": duration_ms}
        )
        return 'Error: Query failed. Please rewrite your query and try again'
    
    # 2) 빈 결과
    if (isinstance(result, list) and len(result) == 0) or result in ("[]", ""):
        logger.info(
            "SQL query returned no results",
            extra={"query": query, "duration_ms": duration_ms}
        )
        return "Answer: No rows found for the given query."
    
    # 3) 정상 결과
    result_size = len(str(result))
    logger.info(
        "SQL query succeeded",
        extra={
            "query": query,
            "duration_ms": duration_ms,
            "result_size_bytes": result_size
        }
    )
    
    return result
```

#### 2.4 그래프 실행 로깅

**파일 수정**: `Agent-yj/src/agent.py`

```python
# Line 601 이후에 추가
# 컴파일 전에 로깅 래퍼 추가
def create_logged_agent(graph):
    """로깅이 추가된 에이전트 래퍼"""
    compiled = graph.compile()
    
    def logged_invoke(input_data, config=None):
        session_id = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        
        logger.info(
            "=== Agent session started ===",
            extra={
                "session_id": session_id,
                "input": str(input_data.get("messages", []))[:200]
            }
        )
        
        start_time = time.time()
        
        try:
            result = compiled.invoke(input_data, config)
            duration_ms = int((time.time() - start_time) * 1000)
            
            logger.info(
                "=== Agent session completed ===",
                extra={
                    "session_id": session_id,
                    "duration_ms": duration_ms,
                    "success": True,
                    "message_count": len(result.get("messages", []))
                }
            )
            
            return result
            
        except Exception as e:
            duration_ms = int((time.time() - start_time) * 1000)
            
            logger.error(
                "=== Agent session failed ===",
                extra={
                    "session_id": session_id,
                    "duration_ms": duration_ms,
                    "success": False,
                    "error_type": type(e).__name__
                },
                exc_info=True
            )
            
            raise
    
    # 원본 메서드 유지하면서 invoke만 래핑
    compiled.invoke = logged_invoke
    return compiled

# Line 602 수정
agent = create_logged_agent(graph_builder)
```

#### 2.5 로그 분석 스크립트

**새 파일 생성**: `Agent-yj/scripts/analyze_logs.py`

```python
"""
로그 파일 분석 스크립트
사용법: python scripts/analyze_logs.py
"""
import json
from pathlib import Path
from collections import defaultdict, Counter
from datetime import datetime

def analyze_logs(log_file):
    """로그 파일을 분석하여 통계 생성"""
    
    logs = []
    with open(log_file, 'r', encoding='utf-8') as f:
        for line in f:
            try:
                logs.append(json.loads(line))
            except:
                continue
    
    print(f"📊 로그 분석 결과: {log_file.name}")
    print(f"총 로그 수: {len(logs)}")
    print()
    
    # 레벨별 통계
    levels = Counter(log['level'] for log in logs)
    print("레벨별 통계:")
    for level, count in levels.items():
        print(f"  {level}: {count}")
    print()
    
    # 에이전트별 실행 시간
    agent_durations = defaultdict(list)
    for log in logs:
        if 'agent_name' in log and 'duration_ms' in log:
            agent_durations[log['agent_name']].append(log['duration_ms'])
    
    if agent_durations:
        print("에이전트별 평균 실행 시간:")
        for agent, durations in sorted(agent_durations.items()):
            avg = sum(durations) / len(durations)
            print(f"  {agent}: {avg:.0f}ms (실행 {len(durations)}회)")
        print()
    
    # 에러 통계
    errors = [log for log in logs if log['level'] == 'ERROR']
    if errors:
        print(f"에러 발생: {len(errors)}건")
        error_types = Counter(log.get('error_type', 'Unknown') for log in errors)
        for error_type, count in error_types.most_common(5):
            print(f"  {error_type}: {count}")
        print()
    
    # 성공/실패율
    sessions = [log for log in logs if 'session_id' in log]
    if sessions:
        completed = len([s for s in sessions if s.get('success') is True])
        failed = len([s for s in sessions if s.get('success') is False])
        total = completed + failed
        if total > 0:
            print(f"세션 성공률: {completed}/{total} ({completed/total*100:.1f}%)")

if __name__ == "__main__":
    log_dir = Path(__file__).parent.parent / "logs"
    
    # 가장 최근 로그 파일 분석
    log_files = sorted(log_dir.glob("agent_*.log"))
    if log_files:
        analyze_logs(log_files[-1])
    else:
        print("로그 파일이 없습니다.")
```

### 작업 체크리스트

- [ ] `src/logger.py` 파일 생성
- [ ] `logs/` 디렉토리 생성 (.gitignore에 추가)
- [ ] `agent.py`에 logger import 추가
- [ ] 모든 print문을 logger로 변경
- [ ] 주요 함수에 로깅 추가
- [ ] `scripts/analyze_logs.py` 생성
- [ ] 테스트: 쿼리 실행 후 로그 확인

---

## 3단계: State 정의 추가 🏗️

### 목표

명확한 State 관리로 에이전트 간 데이터 흐름 개선

### 구현

**파일 수정**: `Agent-yj/src/agent.py`

```python
# Line 27 이후에 추가
from typing import Sequence, Annotated, Literal, Optional, Any, Dict, List
from typing_extensions import TypedDict

class AgentState(TypedDict):
    """
    멀티 에이전트 시스템의 공유 상태
    
    모든 에이전트는 이 상태를 읽고 업데이트합니다.
    """
    # 핵심 메시지
    messages: Sequence[BaseMessage]
    
    # SQL 관련
    sql_query: Optional[str]  # 생성된 SQL 쿼리
    query_results: Optional[str]  # DB 실행 결과
    tables_used: List[str]  # 사용된 테이블 목록
    
    # RAG 관련
    rag_context: Optional[str]  # RAG로 검색된 컨텍스트
    rag_used: bool  # RAG 사용 여부
    
    # 재시도 및 에러
    retry_count: int  # 현재 재시도 횟수
    max_retries: int  # 최대 재시도 횟수
    error_history: List[Dict[str, Any]]  # 에러 히스토리
    last_error: Optional[Dict[str, Any]]  # 마지막 에러
    
    # 실행 메타데이터
    session_id: Optional[str]  # 세션 ID
    start_time: Optional[str]  # 시작 시간
    agent_trace: List[str]  # 실행된 에이전트 목록
    routing_decision: Optional[str]  # 라우팅 결정 (SQL/RAG)
    
    # 사용자 요청
    original_query: str  # 원본 사용자 질문
    interpreted_query: Optional[str]  # 해석된 질문
```

**Line 549 수정**:
```python
# 기존
graph_builder = StateGraph(MessagesState)

# 변경
graph_builder = StateGraph(AgentState)
```

**초기 상태 설정**:
```python
# agent.invoke() 호출 시
from datetime import datetime

def invoke_agent_with_state(user_query: str):
    """State를 초기화하여 에이전트 실행"""
    init_state = {
        "messages": [HumanMessage(content=user_query)],
        "sql_query": None,
        "query_results": None,
        "tables_used": [],
        "rag_context": None,
        "rag_used": False,
        "retry_count": 0,
        "max_retries": 3,
        "error_history": [],
        "last_error": None,
        "session_id": datetime.now().strftime("%Y%m%d_%H%M%S"),
        "start_time": datetime.now().isoformat(),
        "agent_trace": [],
        "routing_decision": None,
        "original_query": user_query,
        "interpreted_query": None
    }
    
    return agent.invoke(init_state)
```

### 작업 체크리스트

- [ ] `AgentState` TypedDict 정의
- [ ] StateGraph 생성 시 AgentState 사용
- [ ] 각 에이전트에서 state 업데이트 로직 추가
- [ ] `invoke_agent_with_state` 헬퍼 함수 생성
- [ ] main.py, streamlit_app.py에서 새 함수 사용

---

## 4단계: main.py 분리 + LangServe 도입 🚀

### 목표

- FastAPI와 Streamlit 완전 분리
- LangServe로 표준화된 API 제공

### 파일 구조 변경

```
Agent-yj/
├── main.py              # FastAPI + LangServe (수정)
├── streamlit_app.py     # Streamlit UI (유지)
├── run_streamlit.py     # Streamlit 실행 스크립트 (신규)
└── api_server.py        # 삭제 또는 백업
```

### 구현

#### 4.1 새로운 main.py (LangServe)

**파일 덮어쓰기**: `Agent-yj/main.py`

```python
"""
한국 주식 AI 에이전트 - FastAPI + LangServe
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from langserve import add_routes
import os
from dotenv import load_dotenv

# 환경변수 로드
load_dotenv()

# 에이전트 import
from src.agent import agent, model_name, RAG_AVAILABLE
from src.logger import logger

# FastAPI 앱 생성
app = FastAPI(
    title="Naver Stock AI Agent API",
    version="2.0.0",
    description="한국 주식 데이터를 자연어로 조회하는 AI 에이전트",
)

# CORS 설정
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# LangServe로 에이전트 라우트 추가
add_routes(
    app,
    agent,
    path="/agent",
    enabled_endpoints=["invoke", "stream", "batch", "playground"],
    enable_feedback_endpoint=True,
    enable_public_trace_link_endpoint=True,
)

@app.get("/")
async def root():
    """API 정보"""
    return {
        "name": "Naver Stock AI Agent API",
        "version": "2.0.0",
        "model": model_name,
        "rag_available": RAG_AVAILABLE,
        "langsmith_enabled": os.getenv("LANGCHAIN_TRACING_V2", "false").lower() == "true",
        "endpoints": {
            "invoke": "/agent/invoke",
            "stream": "/agent/stream",
            "batch": "/agent/batch",
            "playground": "/agent/playground",
            "docs": "/docs",
            "health": "/health"
        }
    }

@app.get("/health")
async def health_check():
    """헬스 체크"""
    return {
        "status": "healthy",
        "model": model_name,
        "rag_available": RAG_AVAILABLE
    }

@app.get("/info")
async def get_info():
    """시스템 상세 정보"""
    return {
        "system": "Naver Stock AI Agent",
        "version": "2.0.0",
        "model": model_name,
        "features": {
            "multi_agent": True,
            "rag": RAG_AVAILABLE,
            "langsmith": os.getenv("LANGCHAIN_TRACING_V2", "false").lower() == "true",
            "supervisor": True,
            "query_interpreter": True,
            "langserve": True,
            "streaming": True
        },
        "agents": [
            "Query_interpreter",
            "SQL_schema_agent",
            "SQL_gen_agent",
            "SQL_check_agent",
            "SQL_execute_agent",
            "RAG_agent" if RAG_AVAILABLE else None,
            "Final_answer_agent",
            "Supervisor"
        ]
    }

if __name__ == "__main__":
    import uvicorn
    
    logger.info("=" * 60)
    logger.info("네이버 주식 AI 에이전트 API 서버 시작")
    logger.info("=" * 60)
    logger.info(f"모델: {model_name}")
    logger.info(f"RAG 사용 가능: {RAG_AVAILABLE}")
    logger.info(f"LangSmith: {os.getenv('LANGCHAIN_TRACING_V2', 'false')}")
    logger.info("=" * 60)
    logger.info("접속 URL: http://localhost:8000")
    logger.info("API 문서: http://localhost:8000/docs")
    logger.info("Playground: http://localhost:8000/agent/playground")
    logger.info("=" * 60)
    
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

#### 4.2 Streamlit 실행 스크립트

**새 파일 생성**: `Agent-yj/run_streamlit.py`

```python
"""
Streamlit 앱 실행 스크립트
"""
import os
import sys
import subprocess

def main():
    """Streamlit 앱을 실행합니다"""
    print("=" * 60)
    print("한국 주식 AI 에이전트 - Streamlit UI")
    print("=" * 60)
    print("\nStreamlit 웹 앱을 실행합니다...")
    print("브라우저가 자동으로 열립니다.")
    print("\n종료하려면 Ctrl+C를 누르세요.")
    print("=" * 60)
    
    # streamlit_app.py의 절대 경로
    streamlit_app_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        "streamlit_app.py"
    )
    
    # Streamlit 실행
    try:
        subprocess.run([
            sys.executable, "-m", "streamlit", "run",
            streamlit_app_path,
            "--server.headless", "false"
        ])
    except KeyboardInterrupt:
        print("\n\n앱을 종료합니다.")
    except Exception as e:
        print(f"\n오류 발생: {e}")
        print("\n직접 실행하려면: streamlit run streamlit_app.py")

if __name__ == "__main__":
    main()
```

#### 4.3 LangServe 사용 예시

**클라이언트 코드 (테스트용)**:

```python
"""
LangServe API 클라이언트 예시
"""
from langserve import RemoteRunnable

# API 연결
agent_api = RemoteRunnable("http://localhost:8000/agent")

# Invoke (동기)
result = agent_api.invoke({
    "messages": [
        {"role": "user", "content": "삼성전자 최근 종가는?"}
    ]
})
print(result)

# Stream (스트리밍)
for chunk in agent_api.stream({
    "messages": [
        {"role": "user", "content": "거래량 상위 10개 종목은?"}
    ]
}):
    print(chunk)
```

### 장점

✅ **자동 생성 엔드포인트**:
- `/agent/invoke` - 동기 호출
- `/agent/stream` - 스트리밍
- `/agent/batch` - 배치 처리
- `/agent/playground` - 웹 UI 테스트

✅ **OpenAPI 스펙 자동 생성**

✅ **타입 안전성**

✅ **LangSmith 통합**

### 작업 체크리스트

- [ ] `requirements.txt`에 `langserve` 추가
- [ ] `main.py` 파일 수정
- [ ] `run_streamlit.py` 파일 생성
- [ ] `api_server.py` 백업 및 제거
- [ ] README.md 업데이트 (실행 방법 변경)
- [ ] 테스트: FastAPI 서버 실행
- [ ] 테스트: Streamlit 앱 실행
- [ ] 테스트: Playground UI 접속

---

## 5단계: Structured Output 적용 🎨

### 목표

주요 에이전트의 출력을 구조화하여 타입 안전성 및 검증 강화

### 구현

#### 5.1 SQL Generation Agent

**파일 수정**: `Agent-yj/src/agent.py`

```python
# Line 150 이후에 추가
class SQLQueryOutput(BaseModel):
    """SQL 쿼리 생성 결과"""
    query: str = Field(description="생성된 SELECT 쿼리")
    tables_used: List[str] = Field(description="쿼리에 사용된 테이블 목록")
    estimated_rows: Optional[int] = Field(
        None, 
        description="예상 결과 행 수 (LIMIT 값 또는 예측)"
    )
    confidence: float = Field(
        default=1.0,
        ge=0.0,
        le=1.0,
        description="쿼리 정확도 신뢰도 (0-1)"
    )
    explanation: Optional[str] = Field(
        None,
        description="쿼리 설명 (선택사항)"
    )

# Line 336-341 수정
sql_gen_agent = create_react_agent(
    model=model_name,
    tools=[],
    prompt=query_gen_prompt,
    name='SQL_gen_agent',
    # Structured output 적용
    response_format=SQLQueryOutput  # 추가
)
```

#### 5.2 Query Interpreter Agent

**파일 수정**: `Agent-yj/src/agent.py`

```python
# Line 150 이후에 추가
class QueryInterpretation(BaseModel):
    """쿼리 해석 결과"""
    action: Literal["pass_through", "rewrite", "need_user_input"] = Field(
        description="처리 액션"
    )
    processed_query: str = Field(
        description="처리된 쿼리 (rewrite된 경우 새 쿼리, 아니면 원본)"
    )
    missing_info: Optional[List[str]] = Field(
        None,
        description="부족한 정보 목록 (need_user_input인 경우)"
    )
    clarification_question: Optional[str] = Field(
        None,
        description="사용자에게 물어볼 질문"
    )
    confidence: float = Field(
        default=1.0,
        description="해석 신뢰도"
    )

# Line 374-379 수정
query_interpreter = create_react_agent(
    model=model_name,
    tools=[],
    prompt=query_interpreter_prompt,
    name='Query_interpreter',
    response_format=QueryInterpretation  # 추가
)
```

#### 5.3 Final Answer Agent

**파일 수정**: `Agent-yj/src/agent.py`

```python
# Line 151-153 수정
class FinalAnswerOutput(BaseModel):
    """최종 답변 출력 (개선)"""
    final_answer: str = Field(
        ..., 
        description="사용자에게 전달할 최종 답변 (한국어)"
    )
    answer_type: Literal["single", "list", "table", "error", "clarification"] = Field(
        description="답변 유형"
    )
    data_points: int = Field(
        default=0,
        description="사용된 데이터 포인트 수"
    )
    sources: Optional[List[str]] = Field(
        None,
        description="데이터 출처 (테이블명 또는 RAG 문서)"
    )
    confidence: float = Field(
        default=1.0,
        description="답변 신뢰도"
    )
    follow_up_suggestions: Optional[List[str]] = Field(
        None,
        description="후속 질문 제안"
    )

# Line 357-362 수정
final_answer_agent = create_react_agent(
    model=model_name,
    tools=[],  # SubmitFinalAnswer 제거
    prompt=final_answer_prompt,
    name='Final_answer_agent',
    response_format=FinalAnswerOutput  # 추가
)
```

### 검증 추가

**파일 수정**: `Agent-yj/src/agent.py`

```python
# SQL 쿼리 검증 함수
def validate_sql_output(output: SQLQueryOutput) -> bool:
    """생성된 SQL 쿼리 검증"""
    query = output.query.strip().upper()
    
    # 기본 검증
    if not query.startswith("SELECT"):
        logger.warning("Invalid SQL: must start with SELECT")
        return False
    
    # 위험한 키워드 차단
    dangerous_keywords = ["DROP", "DELETE", "UPDATE", "INSERT", "ALTER"]
    if any(keyword in query for keyword in dangerous_keywords):
        logger.error(f"Dangerous SQL detected: {query}")
        return False
    
    # LIMIT 확인 (성능)
    if "LIMIT" not in query:
        logger.warning("SQL without LIMIT (performance concern)")
    
    return True
```

### 작업 체크리스트

- [x] `SQLQueryOutput` 모델 정의
- [x] `QueryInterpretation` 모델 정의
- [x] `FinalAnswerOutput` 모델 개선
- [x] 프롬프트 개선 (구조화된 출력 유도)
- [x] 검증 함수 추가 (`validate_sql_query`, `extract_tables_from_query`)
- [x] db_query_tool에 검증 적용
- [ ] 테스트: 구조화된 출력 확인

---

## 📝 작업 순서 요약

1. **1단계** (3-4시간): 에러 핸들링 + 재시도
   - `src/errors.py` 생성
   - `AgentState` 정의
   - `handle_tool_error` 개선
   - 타임아웃 설정

2. **2단계** (2-3시간): 로깅 시스템
   - `src/logger.py` 생성
   - 모든 print → logger 변경
   - 성능 메트릭 추가
   - 로그 분석 스크립트

3. **3단계** (2시간): State 정의
   - `AgentState` TypedDict 완성
   - StateGraph 업데이트
   - 초기화 헬퍼 함수

4. **4단계** (1-2시간): LangServe
   - `main.py` 리팩토링
   - `run_streamlit.py` 생성
   - 엔드포인트 테스트

5. **5단계** (2시간): Structured Output
   - Pydantic 모델 정의
   - 에이전트 업데이트
   - 검증 로직 추가

---

## 🧪 테스트 계획

### 단계별 테스트

**1단계 테스트**:
```python
# 의도적으로 잘못된 쿼리 실행
result = agent.invoke({
    "messages": [{"role": "user", "content": "이상한쿼리@#$"}]
})
# 기대: 최대 3회 재시도 후 명확한 에러 메시지
```

**2단계 테스트**:
```bash
# 로그 파일 확인
python scripts/analyze_logs.py
# 기대: JSON 형식 로그, 에이전트별 실행 시간 통계
```

**3단계 테스트**:
```python
# State 추적 확인
result = agent.invoke(init_state)
print(result.get("agent_trace"))
# 기대: 실행된 모든 에이전트 목록
```

**4단계 테스트**:
```bash
# LangServe Playground 접속
# http://localhost:8000/agent/playground
# 기대: 웹 UI에서 에이전트 테스트 가능
```

**5단계 테스트**:
```python
# 구조화된 출력 확인
# 기대: Pydantic 검증 통과, 타입 안전성
```

---

## 📚 참고 자료

- [LangGraph 공식 문서](https://langchain-ai.github.io/langgraph/)
- [LangServe 가이드](https://python.langchain.com/docs/langserve)
- [Pydantic V2 문서](https://docs.pydantic.dev/latest/)
- [Python Logging Best Practices](https://docs.python.org/3/howto/logging.html)

---

## ✅ 완료 후 기대 효과

| 개선 영역 | 개선 전 | 개선 후 | 효과 |
|---------|--------|--------|------|
| **안정성** | 무한 루프 위험 | 재시도 3회 제한 | 🟢 비용 절감 |
| **관찰성** | print문만 | 구조화된 로깅 | 🟢 디버깅 시간 50% 감소 |
| **유지보수** | 암묵적 상태 | 명시적 State | 🟢 코드 이해도 향상 |
| **개발 경험** | 수동 API 정의 | LangServe 자동화 | 🟢 개발 속도 2배 |
| **코드 품질** | 자유 형식 출력 | Pydantic 검증 | 🟢 타입 안전성 |

---

## 💡 추가 권장사항

### 6단계 (선택): 성능 최적화
- [ ] 쿼리 결과 캐싱 (Redis)
- [ ] DB 연결 풀링
- [ ] 에이전트 병렬 실행 검토

### 7단계 (선택): 보안 강화
- [ ] API 키 인증
- [ ] Rate limiting
- [ ] SQL Injection 방어 강화

### 8단계 (선택): 모니터링
- [ ] Prometheus 메트릭
- [ ] Grafana 대시보드
- [ ] 알림 설정 (에러율 임계값)

---

## 📞 작업 시작 시 체크리스트

- [ ] 현재 코드 백업 (Git commit)
- [ ] 가상환경 활성화
- [ ] 필요한 패키지 설치 (`pip install langserve structlog`)
- [ ] .env 파일 확인
- [ ] 기존 기능 정상 동작 확인

---

**작성자**: AI Assistant  
**최종 수정**: 2026-01-04  
**버전**: 1.0

이 계획서를 바탕으로 단계별로 작업하시면 됩니다. 각 단계는 독립적으로 진행 가능하며, 필요에 따라 순서를 조정할 수 있습니다. 작업 시작 시 이 파일을 열어 체크리스트를 확인하며 진행하시면 됩니다! 🚀

